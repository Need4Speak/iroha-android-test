/*
Copyright Soramitsu Co., Ltd. 2016 All Rights Reserved.
http://soramitsu.co.jp

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package io.soramitsu.irohaandroid;

import android.app.Activity;
import android.support.annotation.NonNull;
import android.util.Log;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import io.soramitsu.irohaandroid.async.BaseIrohaAsyncTask;
import io.soramitsu.irohaandroid.async.DataSet;
import io.soramitsu.irohaandroid.async.IrohaAsyncTask;
import io.soramitsu.irohaandroid.async.IrohaParallelAsyncTask;
import io.soramitsu.irohaandroid.callback.Callback;
import io.soramitsu.irohaandroid.callback.Func2;
import io.soramitsu.irohaandroid.callback.Func3;
import io.soramitsu.irohaandroid.callback.Function;
import io.soramitsu.irohaandroid.model.Account;
import io.soramitsu.irohaandroid.model.Asset;
import io.soramitsu.irohaandroid.model.Domain;
import io.soramitsu.irohaandroid.model.KeyPair;
import io.soramitsu.irohaandroid.model.Transaction;
import io.soramitsu.irohaandroid.service.AccountService;
import io.soramitsu.irohaandroid.service.AssetService;
import io.soramitsu.irohaandroid.service.DomainService;
import io.soramitsu.irohaandroid.service.TransactionService;

/**
 * Iroha client.
 */
public class Iroha {
    private static final String TAG = Iroha.class.getSimpleName();
    private static final int COUNT_TWO_PARALLEL_TASK = 2;
    private static final int COUNT_THREE_PARALLEL_TASK = 3;

    private static Iroha iroha;

    private final AccountService accountService = new AccountService();
    private final DomainService domainService = new DomainService();
    private final AssetService assetService = new AssetService();
    private final TransactionService transactionService = new TransactionService();

    private final Map<String, BaseIrohaAsyncTask<?>> asyncTaskMap = new HashMap<>();

    public String baseUrl;

    /**
     * Iroha constructor.
     *
     * @param builder Iroha builder
     */
    private Iroha(Builder builder) {
        this.baseUrl = builder.baseUrl;
        iroha = this;
    }

    /**
     * Iroha Builder.
     */
    public static class Builder {
        private String baseUrl;

        /**
         * Set url of iroha server.
         *
         * @param baseUrl iroha server url
         * @return builder
         */
        public Builder baseUrl(String baseUrl) {
            this.baseUrl = baseUrl;
            return this;
        }

        /**
         * Build iroha instance.
         *
         * @return iroha client
         */
        public Iroha build() {
            if (baseUrl == null) {
                throw new NullPointerException();
            }
            return new Iroha(this);
        }
    }

    /**
     * Get iroha client instance.
     *
     * @return iroha client
     */
    public static Iroha getInstance() {
        if (iroha == null) {
            throw new NullPointerException();
        }
        return iroha;
    }


    /* ============ 【KeyPair】 from here ============  */

    /**
     * Create KeyPair for iroha client.
     *
     * @return keypair generated by Ed25519
     */
    public static KeyPair createKeyPair() {
        return Ed25519.createKeyPair();
    }

    /**
     * Create signature for iroha.
     *
     * @param keyPair keypair generated by Ed25519
     * @param message message hashed by sha3
     * @return signature
     */
    public static String sign(KeyPair keyPair, String message) {
        return Ed25519.sign(message, keyPair);
    }

    /**
     * Confirm the message with signature.
     *
     * @param publicKey public key from keypair generated by Ed25519
     * @param signature signature
     * @param message   message hashed by sha3
     * @return true if the correct message
     */
    public static boolean verify(String publicKey, String signature, String message) {
        return Ed25519.verify(signature, message, publicKey);
    }

    /* ============ 【KeyPair】 to here ============  */


    /* ============ 【Web API】 from here ============  */

    /**
     * Register iroha account.
     *
     * @param publicKey public key from keypair generated by Ed25519
     * @param alias     account name
     * @return function of register iroha account
     */
    public Function<Account> registerAccountFunction(final String publicKey, final String alias) {
        return new Function<Account>() {
            @Override
            public Account call() throws Exception {
                return accountService.register(publicKey, alias);
            }
        };
    }

    /**
     * Find iroha account by uuid
     *
     * @param uuid iroha account id
     * @return function of find iroha account
     */
    public Function<Account> findAccountFunction(final String uuid) {
        return new Function<Account>() {
            @Override
            public Account call() throws Exception {
                return accountService.findAccount(uuid);
            }
        };
    }

    /**
     * Register domain.
     *
     * @param name      domain name
     * @param owner     domain owner
     * @param signature signature for domain
     * @return function of register domain
     */
    public Function<Domain> registerDomainFunction(
            final String name, final String owner, final String signature) {

        return new Function<Domain>() {
            @Override
            public Domain call() throws Exception {
                return domainService.register(name, owner, signature);
            }
        };
    }

    /**
     * Find all domains.
     *
     * @param limit  limit
     * @param offset offset
     * @return function of find all domains
     */
    public Function<List<Domain>> findDomainsFunction(final int limit, final int offset) {

        return new Function<List<Domain>>() {
            @Override
            public List<Domain> call() throws Exception {
                return domainService.findDomains(limit, offset);
            }
        };
    }

    /**
     * Create asset.
     *
     * @param name      asset name
     * @param domain    domain name associated with this asset
     * @param creator   public key from keypair generated by Ed25519 of asset creator
     * @param signature signature for asset
     * @param timestamp unix timestamp at created asset
     * @return function of create asset
     */
    public Function<Asset> createAssetFunction(
            final String name, final String domain, final String creator,
            final String signature, final long timestamp) {

        return new Function<Asset>() {
            @Override
            public Asset call() throws Exception {
                return assetService.create(name, domain, creator, signature, timestamp);
            }
        };
    }

    /**
     * Find assets by domain name.
     *
     * @param domain domain name associated with this asset
     * @param limit  limit
     * @param offset offset
     * @return function of find assets
     */
    public Function<List<Asset>> findAssetsFunction(
            final String domain, final int limit, final int offset) {

        return new Function<List<Asset>>() {
            @Override
            public List<Asset> call() throws Exception {
                return assetService.findAssets(domain, limit, offset);
            }
        };
    }

    /**
     * Execute command on asset.
     *
     * @param assetUuid asset uuid
     * @param command   command
     * @param value     asset value
     * @param sender    public key from keypair generated by Ed25519 of asset sender
     * @param receiver  public key from keypair generated by Ed25519 of asset receiver
     * @param signature signature for this operation
     * @param timestamp unix timestamp at operated
     * @return function of operate asset
     */
    public Function<Boolean> operateAssetFunction(
            final String assetUuid, final String command, final String value,
            final String sender, final String receiver, final String signature,
            final long timestamp) {

        return new Function<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                return assetService.operation(assetUuid, command, value, sender, receiver, signature, timestamp);
            }
        };
    }

    /**
     * Find transaction history by iroha account uuid.
     *
     * @param uuid   iroha account id
     * @param limit  limit
     * @param offset offset
     * @return function of find transaction history
     */
    public Function<List<Transaction>> findTransactionHistoryFunction(
            final String uuid, final int limit, final int offset) {

        return new Function<List<Transaction>>() {
            @Override
            public List<Transaction> call() throws Exception {
                return transactionService.findHistory(uuid, limit, offset);
            }
        };
    }

    /**
     * Find transaction history by iroha account uuid and domain name and asset name.
     *
     * @param uuid   iroha account id
     * @param domain domain name
     * @param asset  asset name
     * @param limit  limit
     * @param offset offset
     * @return function of find transaction history
     */
    public Function<List<Transaction>> findTransactionHistoryFunction(
            final String uuid, final String domain, final String asset,
            final int limit, final int offset) {

        return new Function<List<Transaction>>() {
            @Override
            public List<Transaction> call() throws Exception {
                return transactionService.findHistory(uuid, domain, asset, limit, offset);
            }
        };
    }

    /* ============ 【Web API】 to here ============  */


    /* ============ 【Async Task Management】 from here ============  */

    /**
     * Execute function with async.
     *
     * @param tag      tag of function
     * @param func     call function
     * @param callback callback for processing called function results
     * @param <T>      object type for result
     */
    public <T> void runAsyncTask(final String tag, final Function<? extends T> func,
                                 final Callback<T> callback) {

        IrohaAsyncTask<T> asyncTask = new IrohaAsyncTask<T>(callback) {
            @Override
            protected T onBackground() throws Exception {
                return func.call();
            }
        };
        execute(tag, asyncTask);
    }

    /**
     * Execute two functions with async.
     *
     * @param activity for execute on main thread
     * @param tag1     tag of f1
     * @param f1       function1
     * @param tag2     tag of f2
     * @param f2       function2
     * @param func2    for merge result func1 and func2
     * @param callback callback for processing called function results
     * @param <T1>     object type for function1
     * @param <T2>     object type for function2
     * @param <R>      object type for result of callback
     */
    public <T1, T2, R> void runParallelAsyncTask(
            final Activity activity,
            final String tag1,
            final Function<? extends T1> f1,
            final String tag2,
            final Function<? extends T2> f2,
            final Func2<? super T1, ? super T2, ? extends R> func2,
            final Callback<R> callback) {

        new Thread(new Runnable() {
            DataSet<T1, T2, Void> dataSet = new DataSet<>();

            @Override
            public void run() {
                try {
                    CountDownLatch countDownLatch = new CountDownLatch(COUNT_TWO_PARALLEL_TASK);

                    IrohaParallelAsyncTask<?> firstParallelAsyncTask =
                            new IrohaParallelAsyncTask<T1>(callback, dataSet, countDownLatch) {
                                @Override
                                protected T1 onBackground() throws Exception {
                                    return f1.call();
                                }
                            };
                    execute(tag1, firstParallelAsyncTask);

                    IrohaParallelAsyncTask<?> secondParallelAsyncTask =
                            new IrohaParallelAsyncTask<T2>(callback, dataSet, countDownLatch) {
                                @Override
                                protected T2 onBackground() throws Exception {
                                    return f2.call();
                                }
                            };
                    execute(tag2, secondParallelAsyncTask);

                    countDownLatch.await();
                    Log.d(TAG, "run: all async task finished.");

                    if (activity == null) {
                        Log.d(TAG, "Background Thread run: success");
                        callback.onSuccessful(func2.call(dataSet.getT1(), dataSet.getT2()));
                    } else {
                        activity.runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                Log.d(TAG, "UI Thread run: success");
                                callback.onSuccessful(func2.call(dataSet.getT1(), dataSet.getT2()));
                            }
                        });
                    }
                } catch (final Exception e) {
                    if (activity == null) {
                        Log.d(TAG, "Background Thread run: failure");
                        callback.onFailure(e);
                    } else {
                        activity.runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                Log.d(TAG, "UI Thread run: failure");
                                callback.onFailure(e);
                            }
                        });
                    }
                }
            }
        }).start();
    }

    /**
     * Execute three functions with async.
     *
     * @param activity for execute on main thread
     * @param tag1     tag of f1
     * @param f1       function1
     * @param tag2     tag of f2
     * @param f2       function2
     * @param tag3     tag of f3
     * @param f3       function3
     * @param func3    for merge result func1 and func2 and func3
     * @param callback callback for processing called function results
     * @param <T1>     object type for function1
     * @param <T2>     object type for function2
     * @param <T3>     object type for function3
     * @param <R>      object type for result of callback
     */
    public <T1, T2, T3, R> void runParallelAsyncTask(
            final Activity activity,
            final String tag1,
            final Function<? extends T1> f1,
            final String tag2,
            final Function<? extends T2> f2,
            final String tag3,
            final Function<? extends T3> f3,
            final Func3<? super T1, ? super T2, ? super T3, ? extends R> func3,
            final Callback<R> callback) {

        new Thread(new Runnable() {
            DataSet<T1, T2, T3> dataSet = new DataSet<>();

            @Override
            public void run() {
                try {
                    CountDownLatch countDownLatch = new CountDownLatch(COUNT_THREE_PARALLEL_TASK);

                    IrohaParallelAsyncTask<?> firstParallelAsyncTask =
                            new IrohaParallelAsyncTask<T1>(callback, dataSet, countDownLatch) {
                                @Override
                                protected T1 onBackground() throws Exception {
                                    return f1.call();
                                }
                            };
                    execute(tag1, firstParallelAsyncTask);

                    IrohaParallelAsyncTask<?> secondParallelAsyncTask =
                            new IrohaParallelAsyncTask<T2>(callback, dataSet, countDownLatch) {
                                @Override
                                protected T2 onBackground() throws Exception {
                                    return f2.call();
                                }
                            };
                    execute(tag2, secondParallelAsyncTask);

                    IrohaParallelAsyncTask<?> threeParallelAsyncTask =
                            new IrohaParallelAsyncTask<T3>(callback, dataSet, countDownLatch) {
                                @Override
                                protected T3 onBackground() throws Exception {
                                    return f3.call();
                                }
                            };
                    execute(tag3, threeParallelAsyncTask);

                    countDownLatch.await();
                    Log.d(TAG, "run: all async task finished.");

                    if (activity == null) {
                        Log.d(TAG, "Background Thread run: success");
                        callback.onSuccessful(func3.call(dataSet.getT1(), dataSet.getT2(), dataSet.getT3()));
                    } else {
                        activity.runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                Log.d(TAG, "UI Thread run: success");
                                callback.onSuccessful(func3.call(dataSet.getT1(), dataSet.getT2(), dataSet.getT3()));
                            }
                        });
                    }
                } catch (final Exception e) {
                    if (activity == null) {
                        Log.d(TAG, "Background Thread run: failure");
                        callback.onFailure(e);
                    } else {
                        activity.runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                Log.d(TAG, "UI Thread run: failure");
                                callback.onFailure(e);
                            }
                        });
                    }
                }
            }
        }).start();
    }

    /**
     * Cancel task by tag.
     *
     * @param tag tag of function
     * @return true if canceled the function
     */
    public boolean cancelAsyncTask(final String tag) {
        Log.d(TAG, "cancelAsyncTask: " + tag);
        BaseIrohaAsyncTask asyncTask = asyncTaskMap.get(tag);
        return asyncTask != null && asyncTask.cancel(true);
    }

    /**
     * Execute task.
     *
     * @param tag          tag of function
     * @param newAsyncTask task
     * @param <C>          object type of task
     */
    private <C extends BaseIrohaAsyncTask<?>> void execute(
            @NonNull final String tag,
            @NonNull C newAsyncTask) {

        asyncTaskMap.put(tag, newAsyncTask);
        newAsyncTask.execute();
    }

    /* ============ 【Async Task Management】 to here ============  */

}
